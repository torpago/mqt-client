/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.19
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"time"
	"bytes"
	"fmt"
	"github.com/shopspring/decimal"
)

// checks if the LedgerEntry type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &LedgerEntry{}

// LedgerEntry Contains information about a ledger entry.
type LedgerEntry struct {
	// Unique identifier of the credit account associated with the credit card used to make the ledger entry.
	AccountToken string `json:"account_token"`
	// Amount of the ledger entry.
	Amount decimal.Decimal `json:"amount"`
	// Unique identifier of the credit card used to make the ledger entry.
	CardToken string `json:"card_token"`
	// Date and time when the ledger entry was created on Marqeta's credit platform, in UTC.
	CreatedTime time.Time `json:"created_time"`
	CurrencyCode CurrencyCode `json:"currency_code"`
	// Contains the ledger entry's full details. The fields returned in this object vary based on the ledger entry group.  The following lists each ledger entry group and the specific fields returned for each group.  * Purchases and refunds: see the <</core-api/transactions#getTransactions, transactions>> response fields.  * Disputes: see the <</core-api/credit-disputes#retrieveDispute, account disputes response fields.>>  * Original credit transaction (OCT): see the <</core-api/push-to-card-payments#_create_push_to_card_disbursement, Push-to-Card disbursement>> fields.  * Rewards: see the <</core-api/credit-account-rewards#createReward, account reward>> response fields.  * Payments: see the <</core-api/credit-account-payments#retrievePayment, account payment>> response fields.  * Balance refunds: see the <</core-api/credit-balance-refunds#createBalanceRefund, balance refund>> response fields.  * Adjustments: see the <</core-api/credit-account-adjustments#retrieveAdjustment, account adjustment>> response fields.  * Interest and fees: see fields below.
	DetailObject map[string]interface{} `json:"detail_object,omitempty"`
	// Unique identifier of the ledger entry's full details.
	DetailToken string `json:"detail_token"`
	// Unique identifier of the dispute, if the ledger entry is disputed.
	DisputeToken *string `json:"dispute_token,omitempty"`
	// Group to which the ledger entry belongs.
	Group string `json:"group"`
	// Eight-digit numeric identifier of the ledger entry, an alternate identifier to the UUID that is useful for remembering and referencing.
	Id string `json:"id"`
	// Date and time when the ledger entry impacts the account balance.  For purchases, this is the time of the authorization.  For purchase authorization clearings, this is the time when the transaction is settled.
	ImpactTime time.Time `json:"impact_time"`
	// Merchant name or description for the ledger entry.
	Memo string `json:"memo"`
	OriginalCurrency *OriginalCurrency `json:"original_currency,omitempty"`
	// Unique identifier of the original ledger entry. If the current ledger entry is the original, this field is returned empty.
	RelatedToken *string `json:"related_token,omitempty"`
	// For purchases, the date and time of the authorization, which is when the user initiates the ledger entry.  For other ledger entry groups, equivalent to `impact_time`.
	RequestTime time.Time `json:"request_time"`
	// Unique identifier of the root ledger entry. If the current ledger entry is the root, this field is returned empty.
	RootToken *string `json:"root_token,omitempty"`
	// Status of the ledger entry when it was initially recorded and had an impact on the balance, either `PENDING` or `POSTED`. This field is immutable and may not represent the current status.  To view the current status of purchases, refunds, OCTs, and payments, see the `detail_object.state` field. These journal entries start in `PENDING` and can transition to `CLEARED`, `DECLINED`, or `ERROR`. This transition of status is only sent through webhook event notifications.  Ledger entries that are final transactions, such as clearings, start and remain in a `POSTED` state.  *NOTE*: `CLEARED`, `DECLINED`, and `ERROR` are special statuses that do not have an impact on the account balance, and are not recorded in the ledger. For these special statuses, `impact_time`, `request_time`, `created_time`, `token`, and `id` are returned blank.
	Status string `json:"status"`
	// Unique identifier of the ledger entry.
	Token string `json:"token"`
	// Ledger entry event type.
	Type string `json:"type"`
}

type _LedgerEntry LedgerEntry

// NewLedgerEntry instantiates a new LedgerEntry object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLedgerEntry(accountToken string, amount decimal.Decimal, cardToken string, createdTime time.Time, currencyCode CurrencyCode, detailToken string, group string, id string, impactTime time.Time, memo string, requestTime time.Time, status string, token string, type_ string) *LedgerEntry {
	this := LedgerEntry{}
	this.AccountToken = accountToken
	this.Amount = amount
	this.CardToken = cardToken
	this.CreatedTime = createdTime
	this.CurrencyCode = currencyCode
	this.DetailToken = detailToken
	this.Group = group
	this.Id = id
	this.ImpactTime = impactTime
	this.Memo = memo
	this.RequestTime = requestTime
	this.Status = status
	this.Token = token
	this.Type = type_
	return &this
}

// NewLedgerEntryWithDefaults instantiates a new LedgerEntry object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLedgerEntryWithDefaults() *LedgerEntry {
	this := LedgerEntry{}
	var currencyCode CurrencyCode = CURRENCYCODE_USD
	this.CurrencyCode = currencyCode
	return &this
}

// GetAccountToken returns the AccountToken field value
func (o *LedgerEntry) GetAccountToken() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.AccountToken
}

// GetAccountTokenOk returns a tuple with the AccountToken field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetAccountTokenOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AccountToken, true
}

// SetAccountToken sets field value
func (o *LedgerEntry) SetAccountToken(v string) {
	o.AccountToken = v
}

// GetAmount returns the Amount field value
func (o *LedgerEntry) GetAmount() decimal.Decimal {
	if o == nil {
		var ret decimal.Decimal
		return ret
	}

	return o.Amount
}

// GetAmountOk returns a tuple with the Amount field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetAmountOk() (*decimal.Decimal, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Amount, true
}

// SetAmount sets field value
func (o *LedgerEntry) SetAmount(v decimal.Decimal) {
	o.Amount = v
}

// GetCardToken returns the CardToken field value
func (o *LedgerEntry) GetCardToken() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.CardToken
}

// GetCardTokenOk returns a tuple with the CardToken field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetCardTokenOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CardToken, true
}

// SetCardToken sets field value
func (o *LedgerEntry) SetCardToken(v string) {
	o.CardToken = v
}

// GetCreatedTime returns the CreatedTime field value
func (o *LedgerEntry) GetCreatedTime() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.CreatedTime
}

// GetCreatedTimeOk returns a tuple with the CreatedTime field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetCreatedTimeOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CreatedTime, true
}

// SetCreatedTime sets field value
func (o *LedgerEntry) SetCreatedTime(v time.Time) {
	o.CreatedTime = v
}

// GetCurrencyCode returns the CurrencyCode field value
func (o *LedgerEntry) GetCurrencyCode() CurrencyCode {
	if o == nil {
		var ret CurrencyCode
		return ret
	}

	return o.CurrencyCode
}

// GetCurrencyCodeOk returns a tuple with the CurrencyCode field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetCurrencyCodeOk() (*CurrencyCode, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CurrencyCode, true
}

// SetCurrencyCode sets field value
func (o *LedgerEntry) SetCurrencyCode(v CurrencyCode) {
	o.CurrencyCode = v
}

// GetDetailObject returns the DetailObject field value if set, zero value otherwise.
func (o *LedgerEntry) GetDetailObject() map[string]interface{} {
	if o == nil || IsNil(o.DetailObject) {
		var ret map[string]interface{}
		return ret
	}
	return o.DetailObject
}

// GetDetailObjectOk returns a tuple with the DetailObject field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetDetailObjectOk() (map[string]interface{}, bool) {
	if o == nil || IsNil(o.DetailObject) {
		return map[string]interface{}{}, false
	}
	return o.DetailObject, true
}

// HasDetailObject returns a boolean if a field has been set.
func (o *LedgerEntry) HasDetailObject() bool {
	if o != nil && !IsNil(o.DetailObject) {
		return true
	}

	return false
}

// SetDetailObject gets a reference to the given map[string]interface{} and assigns it to the DetailObject field.
func (o *LedgerEntry) SetDetailObject(v map[string]interface{}) {
	o.DetailObject = v
}

// GetDetailToken returns the DetailToken field value
func (o *LedgerEntry) GetDetailToken() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.DetailToken
}

// GetDetailTokenOk returns a tuple with the DetailToken field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetDetailTokenOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.DetailToken, true
}

// SetDetailToken sets field value
func (o *LedgerEntry) SetDetailToken(v string) {
	o.DetailToken = v
}

// GetDisputeToken returns the DisputeToken field value if set, zero value otherwise.
func (o *LedgerEntry) GetDisputeToken() string {
	if o == nil || IsNil(o.DisputeToken) {
		var ret string
		return ret
	}
	return *o.DisputeToken
}

// GetDisputeTokenOk returns a tuple with the DisputeToken field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetDisputeTokenOk() (*string, bool) {
	if o == nil || IsNil(o.DisputeToken) {
		return nil, false
	}
	return o.DisputeToken, true
}

// HasDisputeToken returns a boolean if a field has been set.
func (o *LedgerEntry) HasDisputeToken() bool {
	if o != nil && !IsNil(o.DisputeToken) {
		return true
	}

	return false
}

// SetDisputeToken gets a reference to the given string and assigns it to the DisputeToken field.
func (o *LedgerEntry) SetDisputeToken(v string) {
	o.DisputeToken = &v
}

// GetGroup returns the Group field value
func (o *LedgerEntry) GetGroup() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Group
}

// GetGroupOk returns a tuple with the Group field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetGroupOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Group, true
}

// SetGroup sets field value
func (o *LedgerEntry) SetGroup(v string) {
	o.Group = v
}

// GetId returns the Id field value
func (o *LedgerEntry) GetId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Id
}

// GetIdOk returns a tuple with the Id field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Id, true
}

// SetId sets field value
func (o *LedgerEntry) SetId(v string) {
	o.Id = v
}

// GetImpactTime returns the ImpactTime field value
func (o *LedgerEntry) GetImpactTime() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.ImpactTime
}

// GetImpactTimeOk returns a tuple with the ImpactTime field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetImpactTimeOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ImpactTime, true
}

// SetImpactTime sets field value
func (o *LedgerEntry) SetImpactTime(v time.Time) {
	o.ImpactTime = v
}

// GetMemo returns the Memo field value
func (o *LedgerEntry) GetMemo() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Memo
}

// GetMemoOk returns a tuple with the Memo field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetMemoOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Memo, true
}

// SetMemo sets field value
func (o *LedgerEntry) SetMemo(v string) {
	o.Memo = v
}

// GetOriginalCurrency returns the OriginalCurrency field value if set, zero value otherwise.
func (o *LedgerEntry) GetOriginalCurrency() OriginalCurrency {
	if o == nil || IsNil(o.OriginalCurrency) {
		var ret OriginalCurrency
		return ret
	}
	return *o.OriginalCurrency
}

// GetOriginalCurrencyOk returns a tuple with the OriginalCurrency field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetOriginalCurrencyOk() (*OriginalCurrency, bool) {
	if o == nil || IsNil(o.OriginalCurrency) {
		return nil, false
	}
	return o.OriginalCurrency, true
}

// HasOriginalCurrency returns a boolean if a field has been set.
func (o *LedgerEntry) HasOriginalCurrency() bool {
	if o != nil && !IsNil(o.OriginalCurrency) {
		return true
	}

	return false
}

// SetOriginalCurrency gets a reference to the given OriginalCurrency and assigns it to the OriginalCurrency field.
func (o *LedgerEntry) SetOriginalCurrency(v OriginalCurrency) {
	o.OriginalCurrency = &v
}

// GetRelatedToken returns the RelatedToken field value if set, zero value otherwise.
func (o *LedgerEntry) GetRelatedToken() string {
	if o == nil || IsNil(o.RelatedToken) {
		var ret string
		return ret
	}
	return *o.RelatedToken
}

// GetRelatedTokenOk returns a tuple with the RelatedToken field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetRelatedTokenOk() (*string, bool) {
	if o == nil || IsNil(o.RelatedToken) {
		return nil, false
	}
	return o.RelatedToken, true
}

// HasRelatedToken returns a boolean if a field has been set.
func (o *LedgerEntry) HasRelatedToken() bool {
	if o != nil && !IsNil(o.RelatedToken) {
		return true
	}

	return false
}

// SetRelatedToken gets a reference to the given string and assigns it to the RelatedToken field.
func (o *LedgerEntry) SetRelatedToken(v string) {
	o.RelatedToken = &v
}

// GetRequestTime returns the RequestTime field value
func (o *LedgerEntry) GetRequestTime() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.RequestTime
}

// GetRequestTimeOk returns a tuple with the RequestTime field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetRequestTimeOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.RequestTime, true
}

// SetRequestTime sets field value
func (o *LedgerEntry) SetRequestTime(v time.Time) {
	o.RequestTime = v
}

// GetRootToken returns the RootToken field value if set, zero value otherwise.
func (o *LedgerEntry) GetRootToken() string {
	if o == nil || IsNil(o.RootToken) {
		var ret string
		return ret
	}
	return *o.RootToken
}

// GetRootTokenOk returns a tuple with the RootToken field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetRootTokenOk() (*string, bool) {
	if o == nil || IsNil(o.RootToken) {
		return nil, false
	}
	return o.RootToken, true
}

// HasRootToken returns a boolean if a field has been set.
func (o *LedgerEntry) HasRootToken() bool {
	if o != nil && !IsNil(o.RootToken) {
		return true
	}

	return false
}

// SetRootToken gets a reference to the given string and assigns it to the RootToken field.
func (o *LedgerEntry) SetRootToken(v string) {
	o.RootToken = &v
}

// GetStatus returns the Status field value
func (o *LedgerEntry) GetStatus() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Status
}

// GetStatusOk returns a tuple with the Status field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetStatusOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Status, true
}

// SetStatus sets field value
func (o *LedgerEntry) SetStatus(v string) {
	o.Status = v
}

// GetToken returns the Token field value
func (o *LedgerEntry) GetToken() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Token
}

// GetTokenOk returns a tuple with the Token field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetTokenOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Token, true
}

// SetToken sets field value
func (o *LedgerEntry) SetToken(v string) {
	o.Token = v
}

// GetType returns the Type field value
func (o *LedgerEntry) GetType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Type
}

// GetTypeOk returns a tuple with the Type field value
// and a boolean to check if the value has been set.
func (o *LedgerEntry) GetTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Type, true
}

// SetType sets field value
func (o *LedgerEntry) SetType(v string) {
	o.Type = v
}

func (o LedgerEntry) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o LedgerEntry) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["account_token"] = o.AccountToken
	toSerialize["amount"] = o.Amount
	toSerialize["card_token"] = o.CardToken
	toSerialize["created_time"] = o.CreatedTime
	toSerialize["currency_code"] = o.CurrencyCode
	if !IsNil(o.DetailObject) {
		toSerialize["detail_object"] = o.DetailObject
	}
	toSerialize["detail_token"] = o.DetailToken
	if !IsNil(o.DisputeToken) {
		toSerialize["dispute_token"] = o.DisputeToken
	}
	toSerialize["group"] = o.Group
	toSerialize["id"] = o.Id
	toSerialize["impact_time"] = o.ImpactTime
	toSerialize["memo"] = o.Memo
	if !IsNil(o.OriginalCurrency) {
		toSerialize["original_currency"] = o.OriginalCurrency
	}
	if !IsNil(o.RelatedToken) {
		toSerialize["related_token"] = o.RelatedToken
	}
	toSerialize["request_time"] = o.RequestTime
	if !IsNil(o.RootToken) {
		toSerialize["root_token"] = o.RootToken
	}
	toSerialize["status"] = o.Status
	toSerialize["token"] = o.Token
	toSerialize["type"] = o.Type
	return toSerialize, nil
}

func (o *LedgerEntry) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"account_token",
		"amount",
		"card_token",
		"created_time",
		"currency_code",
		"detail_token",
		"group",
		"id",
		"impact_time",
		"memo",
		"request_time",
		"status",
		"token",
		"type",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varLedgerEntry := _LedgerEntry{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varLedgerEntry)

	if err != nil {
		return err
	}

	*o = LedgerEntry(varLedgerEntry)

	return err
}

type NullableLedgerEntry struct {
	value *LedgerEntry
	isSet bool
}

func (v NullableLedgerEntry) Get() *LedgerEntry {
	return v.value
}

func (v *NullableLedgerEntry) Set(val *LedgerEntry) {
	v.value = val
	v.isSet = true
}

func (v NullableLedgerEntry) IsSet() bool {
	return v.isSet
}

func (v *NullableLedgerEntry) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLedgerEntry(val *LedgerEntry) *NullableLedgerEntry {
	return &NullableLedgerEntry{value: val, isSet: true}
}

func (v NullableLedgerEntry) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLedgerEntry) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


